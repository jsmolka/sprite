var kCycles = [
  0x04, 0x0C, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04, 0x14, 0x08, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x0C, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04, 0x0C, 0x08, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04,
  0x08, 0x0C, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04,
  0x08, 0x0C, 0x08, 0x08, 0x0C, 0x0C, 0x0C, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04,
  0x08, 0x0C, 0x0C, 0x10, 0x0C, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0C, 0x08, 0x0C, 0x18, 0x08, 0x10,
  0x08, 0x0C, 0x0C, 0x00, 0x0C, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0C, 0x00, 0x0C, 0x00, 0x08, 0x10,
  0x0C, 0x0C, 0x08, 0x00, 0x00, 0x10, 0x08, 0x10, 0x10, 0x04, 0x10, 0x00, 0x00, 0x00, 0x08, 0x10,
  0x0C, 0x0C, 0x08, 0x04, 0x00, 0x10, 0x08, 0x10, 0x0C, 0x08, 0x10, 0x04, 0x00, 0x00, 0x08, 0x10
]

var kPalette = [0xFFC6DE8C, 0xFF84A563, 0xFF396139, 0xFF081810]

var kScreenW = 160
var kScreenH = 144

var kStatLine   = 1 << 6
var kStatOam    = 1 << 5
var kStatVBlank = 1 << 4
var kStatHBlank = 1 << 3

var kInterruptVBlank = 1 << 0
var kInterruptStat   = 1 << 1
var kInterruptTimer  = 1 << 2
var kInterruptSerial = 1 << 3
var kInterruptJoypad = 1 << 4

var kModeHBlank = 0
var kModeVBlank = 1
var kModeOam    = 2
var kModeVram   = 3

def min(a, b):
  if a < b:
    return a
  else:
    return b
    
def sign_extend(value):
  return (value << 56) >> 56
  
def color(palette, index):
  return kPalette[(palette >> (2 * index)) & 0x3]

class GameBoy:
  def init():
    this.window = sdl_window("sprite", kScreenW, kScreenH, 2)
  
    this.a = 0x01
    this.f = 0xB0
    this.b = 0x00
    this.c = 0x13
    this.d = 0x00
    this.e = 0xD8
    this.h = 0x01
    this.l = 0x4D

    this.pc   = 0x0100
    this.sp   = 0xFFFE
    this.halt = 0
    this.ie   = 0
    this.ime  = 1

    this.rom = null
    this.vram = bytes()
    this.vram.resize(0x2000, 0)
    this.wram = bytes()
    this.wram.resize(0x2000, 0)
    this.eram = bytes()
    this.eram.resize(0x2000, 0)
    this.oram = bytes()
    this.oram.resize(0x0100, 0)
    this.hram = bytes()
    this.hram.resize(0x007F, 0)

    this.joyp        = 0xCF
    this.sb          = 0x00
    this.sc          = 0x7E
    this.div         = 0xAC
    this.div_cycles  = 0x00
    this.tima        = 0x00
    this.tima_cycles = 0x00
    this.tma         = 0x00
    this.tac         = 0xF8
    this.if_         = 0xE1
    this.nr10        = 0x80
    this.nr11        = 0xBF
    this.nr12        = 0xF3
    this.nr14        = 0xBF
    this.nr21        = 0x3F
    this.nr22        = 0x00
    this.nr24        = 0xBF
    this.nr30        = 0x7F
    this.nr31        = 0xFF
    this.nr32        = 0x9F
    this.nr34        = 0xBF
    this.nr41        = 0xFF
    this.nr42        = 0x00
    this.nr43        = 0x00
    this.nr44        = 0xBF
    this.nr50        = 0x77
    this.nr51        = 0xF3
    this.nr52        = 0xF1
    this.lcdc        = 0x91
    this.stat        = 0x80
    this.ppu_mode    = 0x00
    this.ppu_cycles  = 0x00
    this.scx         = 0x00
    this.scy         = 0x00
    this.ly          = 0x00
    this.lyc         = 0x00
    this.dma         = 0x00
    this.bgp         = 0xCF
    this.obp0        = 0xFF
    this.obp1        = 0xFF
    this.wx          = 0x00
    this.wy          = 0x00

  def af():
    return this.f | (this.a << 8)

  def set_af(value):
    this.f = value & 0xF0
    this.a = (value >> 8) & 0xFF

  def bc():
    return this.c | (this.b << 8)

  def set_bc(value):
    this.c = value & 0xFF
    this.b = (value >> 8) & 0xFF

  def de():
    return this.e | (this.d << 8)

  def set_de(value):
    this.e = value & 0xFF
    this.d = (value >> 8) & 0xFF

  def hl():
    return this.l | (this.h << 8)

  def set_hl(value):
    this.l = value & 0xFF
    this.h = (value >> 8) & 0xFF

  def fz():
    return (this.f >> 7) & 0x1

  def fn():
    return (this.f >> 6) & 0x1

  def fh():
    return (this.f >> 5) & 0x1

  def fc():
    return (this.f >> 4) & 0x1

  def set_f(z, n, h, c):
    var f = this.f
    if z != null:
      if z:
        f = f | 0x80
      else:
        f = f & ~0x80
    if n != null:
      if n:
        f = f | 0x40
      else:
        f = f & ~0x40
    if h != null:
      if h:
        f = f | 0x20
      else:
        f = f & ~0x20
    if c != null:
      if c:
        f = f | 0x10
      else:
        f = f & ~0x10
    this.f = f
    
  def lcd_enabled():
    return this.lcdc & (1 << 7)

  def read_byte_io(addr):
    switch addr:
      case 0x00:
        var value = this.joyp & 0b00110000
        if (this.joyp & (1 << 4)) == 0:
          value = value | (sdl_keystate( 7) << 0)
          value = value | (sdl_keystate( 4) << 1)
          value = value | (sdl_keystate(26) << 2)
          value = value | (sdl_keystate(22) << 3)
        else:
          value = value | (sdl_keystate(24) << 0)
          value = value | (sdl_keystate(11) << 1)
          value = value | (sdl_keystate( 9) << 2)
          value = value | (sdl_keystate(10) << 3)
        return (value ^ 0b00001111) | 0b11000000
      case 0x01:
        return this.sb
      case 0x02:
        return this.sc | 0b01111110
      case 0x04:
        return this.div
      case 0x05:
        return this.tima
      case 0x06:
        return this.tma
      case 0x07:
        return this.tac | 0b11111000
      case 0x0F:
        return this.if_ | 0b11100000
      case 0x10:
        return this.nr10 | 0b10000000
      case 0x11:
        return this.nr11
      case 0x12:
        return this.nr12
      case 0x14:
        return this.nr14
      case 0x16:
        return this.nr21
      case 0x17:
        return this.nr22
      case 0x19:
        return this.nr24
      case 0x1A:
        return this.nr30 | 0b01111111
      case 0x1B:
        return this.nr31
      case 0x1C:
        return this.nr32 | 0b10011111
      case 0x1E:
        return this.nr34
      case 0x20:
        return this.nr41 | 0b11000000
      case 0x21:
        return this.nr42
      case 0x22:
        return this.nr43
      case 0x23:
        return this.nr44 | 0b00111111
      case 0x24:
        return this.nr50
      case 0x25:
        return this.nr51
      case 0x26:
        return this.nr52 | 0b01110000
      case 0x40:
        return this.lcdc
      case 0x41:
        return this.stat | ((this.ly == this.lyc) << 2) | this.ppu_mode | 0b10000000
      case 0x42:
        return this.scy
      case 0x43:
        return this.scx
      case 0x44:
        return this.ly
      case 0x45:
        return this.lyc
      case 0x46:
        return this.dma
      case 0x47:
        return this.bgp
      case 0x48:
        return this.obp0
      case 0x49:
        return this.obp1
      case 0x4A:
        return this.wy
      case 0x4B:
        return this.wx
    return 0xFF

  def read_byte(addr):
    switch addr >> 12:
      case 0x0:
      case 0x1:
      case 0x2:
      case 0x3:
        return this.rom[addr]
      case 0x4:
      case 0x5:
      case 0x6:
      case 0x7:
        return this.rom[addr]  # Todo: implement MBC
      case 0x8:
      case 0x9:
        if this.lcd_enabled() && this.ppu_mode == kModeVram:
          return 0xFF
        else:
          return this.vram[addr - 0x8000]
      case 0xA:
      case 0xB:
        return this.eram[addr - 0xA000]
      case 0xC:
      case 0xD:
        return this.wram[addr - 0xC000]
      case 0xE:
        return this.read_byte(addr - 0xC000)
      case 0xF:
        if addr < 0xFE00:
          return this.read_byte(addr - 0x2000)
        elif addr < 0xFEA0:
          if this.lcd_enabled():
            switch this.ppu_mode:
              case kModeOam:
              case kModeVram:
                return 0xFF
          return oram[addr - 0xFE00]
        elif addr < 0xFF00:
          return 0xFF
        elif addr < 0xFF80:
          return this.read_byte_io(addr - 0xFF00)
        elif addr < 0xFFFF:
          return this.hram[addr - 0xFF80]
        else:
          return this.ie
    return 0xFF

  def read_byte_pc():
    var value = this.read_byte(this.pc)
    this.pc = (this.pc + 1) & 0xFFFF
    return value

  def read_signed_byte_pc():
    return sign_extend(this.read_byte_pc())

  def read_half(addr):
    return this.read_byte(addr) | (this.read_byte(addr + 1) << 8)

  def read_half_pc():
    var value = this.read_half(this.pc)
    this.pc = (this.pc + 2) & 0xFFFF
    return value

  def write_byte_io(addr, byte):
    switch addr:
      case 0x00:
        this.joyp = byte & 0x11110000
      case 0x01:
        this.sb = byte
      case 0x02:
        this.sc = byte
      case 0x04:
        this.div = 0
        this.div_cycles = 0
        this.tima_cycles = 0
      case 0x05:
        this.tima = byte
      case 0x06:
        this.tma = byte
      case 0x07:
        this.tac = byte
      case 0x0F:
        this.if_ = byte
      case 0x10:
        this.nr10 = byte
      case 0x11:
        this.nr11 = byte
      case 0x12:
        this.nr12 = byte
      case 0x14:
        this.nr14 = byte
      case 0x16:
        this.nr21 = byte
      case 0x17:
        this.nr22 = byte
      case 0x19:
        this.nr24 = byte
      case 0x1A:
        this.nr30 = byte
      case 0x1B:
        this.nr31 = byte
      case 0x1C:
        this.nr32 = byte
      case 0x1E:
        this.nr34 = byte
      case 0x20:
        this.nr41 = byte
      case 0x21:
        this.nr42 = byte
      case 0x22:
        this.nr43 = byte
      case 0x23:
        this.nr44 = byte
      case 0x24:
        this.nr50 = byte
      case 0x25:
        this.nr51 = byte
      case 0x26:
        this.nr52 = byte
      case 0x40:
        this.lcdc = byte
      case 0x41:
        this.stat = byte & 0b11111000
      case 0x42:
        this.scy = byte
      case 0x43:
        this.scx = byte
      case 0x44:
        noop
      case 0x45:
        this.lyc = byte
      case 0x46:
        this.dma = byte
        this.oam_dma(byte)
      case 0x47:
        this.bgp = byte
      case 0x48:
        this.obp0 = byte
      case 0x49:
        this.obp1 = byte
      case 0x4A:
        this.wy = byte
      case 0x4B:
        this.wx = byte

  def write_byte(addr, byte):
    switch addr >> 12:
      case 0x0:
      case 0x1:
      case 0x2:
      case 0x3:
      case 0x4:
      case 0x5:
      case 0x6:
      case 0x7:
        noop
      case 0x8:
      case 0x9:
        if this.lcd_enabled() && this.ppu_mode == kModeVram:
          return
        this.vram[addr - 0x8000] = byte
      case 0xA:
      case 0xB:
        this.eram[addr - 0xA000] = byte
      case 0xC:
      case 0xD:
        this.wram[addr - 0xC000] = byte
      case 0xE:
        this.write_byte(addr - 0x2000, byte)
      case 0xF:
        if addr < 0xFE00:
          this.write_byte(addr - 0x2000, byte)
        elif addr < 0xFEA0:
          if this.lcd_enabled():
            switch this.ppu_mode:
              case kModeOam:
              case kModeVram:
                return
          this.oram[addr - 0xFE00] = byte
        elif addr < 0xFF00:
          noop
        elif addr < 0xFF80:
          this.write_byte_io(addr - 0xFF00, byte)
        elif addr < 0xFFFF:
          this.hram[addr - 0xFF80] = byte
        else:
          this.ie = byte

  def write_half(addr, half):
    this.write_byte(addr, half & 0xFF)
    this.write_byte(addr + 1, (half >> 8) & 0xFF)

  def inc(value):
    value = (value + 1) & 0xFF
    this.set_f(value == 0, 0, (value & 0x0F) == 0x00, null)
    return value

  def dec(value):
    value = (value - 1) & 0xFF
    this.set_f(value == 0, 1, (value & 0x0F) == 0x0F, null)
    return value

  def add(other):
    var value = this.a + other
    this.set_f((value & 0xFF) == 0, 0, (this.a ^ other ^ value) & 0x10, value & 0xFF00)
    this.a = value & 0xFF

  def add_half(other):
    var value = this.hl() + other
    this.set_f(null, 0, (this.hl() ^ other ^ value) & 0x1000, value & 0xFFFF0000)
    this.set_hl(value)
    
  def add_signed_byte(value):
    var byte = this.read_signed_byte_pc()
    this.set_f(0, 0, (value & 0xF) + (byte & 0xF) > 0xF, (value & 0xFF) + (byte & 0xFF) > 0xFF)
    return value + byte

  def adc(other):
    var value = this.a + other + this.fc()
    this.set_f((value & 0xFF) == 0, 0, (this.a ^ other ^ value) & 0x10, value & 0xFF00)
    this.a = value & 0xFF

  def sub(other):
    var value = this.a - other
    this.set_f((value & 0xFF) == 0, 1, (this.a ^ other ^ value) & 0x10, value & 0xFF00)
    this.a = value & 0xFF

  def sbc(other):
    var value = this.a - other - this.fc()
    this.set_f((value & 0xFF) == 0, 1, (this.a ^ other ^ value) & 0x10, value & 0xFF00)
    this.a = value & 0xFF

  def cp(other):
    var value = this.a - other
    this.set_f((value & 0xFF) == 0, 1, (this.a ^ other ^ value) & 0x10, value & 0xFF00)

  def and(other):
    this.a = this.a & other
    this.set_f(this.a == 0, 0, 1, 0)

  def xor(other):
    this.a = this.a ^ other
    this.set_f(this.a == 0, 0, 0, 0)

  def or(other):
    this.a = this.a | other
    this.set_f(this.a == 0, 0, 0, 0)

  def jp(condition):
    if condition == null || condition:
      this.pc = this.read_half_pc()
      if condition != null:
        this.tick(4)
    else:
      this.pc = (this.pc + 2) & 0xFFFF

  def jr(condition):
    var offset = 1
    if condition == null || condition:
      offset = this.read_signed_byte_pc()
      if condition != null:
        this.tick(4)
    this.pc = (this.pc + offset) & 0xFFFF

  def push(value):
    this.sp = (this.sp - 2) & 0xFFFF
    this.write_half(this.sp, value)

  def pop():
    var value = this.read_half(this.sp)
    this.sp = (this.sp + 2) & 0xFFFF
    return value

  def call(condition):
    if condition == null || condition:
      var addr = this.read_half_pc()
      this.push(this.pc)
      this.pc = addr
      if condition != null:
        this.tick(12)
    else:
      this.pc = (this.pc + 2) & 0xFFFF

  def ret(condition):
    if condition == null || condition:
      this.pc = this.pop()
      if condition != null:
        this.tick(12)

  def rst(addr):
    this.push(this.pc)
    this.pc = addr

  def daa():
    if this.fn():
      if this.fh():
        this.a = (this.a - 0x06) & 0x00FF
      if this.fc():
        this.a = (this.a - 0x60) & 0xFFFF
    else:
      if this.fh() || (this.a & 0x000F) > 0x09:
        this.a = (this.a + 0x06) & 0xFFFF
      if this.fc() || (this.a & 0xFFFF) > 0x9F:
        this.a = (this.a + 0x60) & 0xFFFF
    if (this.a & 0x100) == 0x100:
      this.set_f(null, null, null, 1)
    this.a = this.a & 0xFF
    this.set_f(this.a == 0, null, 0, null)

  def cpu():
    if this.halt:
      this.tick(kCycles[0])
      return

    var opcode = this.read_byte_pc()
    switch opcode:
      case 0x00:  # NOP
        noop
      case 0x01:  # LD BC, u16
        this.c = this.read_byte_pc()
        this.b = this.read_byte_pc()
      case 0x02:  # LD (BC), A
        this.write_byte(this.bc(), this.a)
      case 0x03:  # INC BC
        this.set_bc(this.bc() + 1)
      case 0x04:  # INC B
        this.b = this.inc(this.b)
      case 0x05:  # DEC B
        this.b = this.dec(this.b)
      case 0x06:  # LD B, u8
        this.b = this.read_byte_pc()
      case 0x07:  # RLCA
        this.a = ((this.a << 1) | (this.a >> 7)) & 0xFF
        this.set_f(0, 0, 0, this.a & 0x1)
      case 0x08:  # LD (u16), SP
        this.write_half(this.read_half_pc(), this.sp)
      case 0x09:  # ADD HL, BC
        this.add_half(this.bc())
      case 0x0A:  # LD A, (BC)
        this.a = this.read_byte(this.bc())
      case 0x0B:  # DEC BC
        this.set_bc(this.bc() - 1)
      case 0x0C:  # INC C
        this.c = this.inc(this.c)
      case 0x0D:  # DEC C
        this.c = this.dec(this.c)
      case 0x0E:  # LD C, u8
        this.c = this.read_byte_pc()
      case 0x0F:  # RRCA
        this.set_f(0, 0, 0, this.a & 0x1)
        this.a = ((this.a >> 1) | (this.a << 7)) & 0xFF
      case 0x10:  # STOP
        noop
      case 0x11:  # LD DE, u16
        this.e = this.read_byte_pc()
        this.d = this.read_byte_pc()
      case 0x12:  # LD (DE), A
        this.write_byte(this.de(), this.a)
      case 0x13:  # INC DE
        this.set_de(this.de() + 1)
      case 0x14:  # INC D
        this.d = this.inc(this.d)
      case 0x15:  # DEC D
        this.d = this.dec(this.d)
      case 0x16:  # LD D, u8
        this.d = this.read_byte_pc()
      case 0x17:  # RLA
        this.a = (this.a << 1) | this.fc()
        this.set_f(0, 0, 0, this.a >> 8)
        this.a = this.a & 0xFF
      case 0x18:  # JR s8
        this.jr(null)
      case 0x19:  # ADD HL, DE
        this.add_half(this.de())
      case 0x1A:  # LD A, (DE)
        this.a = this.read_byte(this.de())
      case 0x1B:  # DEC DE
        this.set_de(this.de() - 1)
      case 0x1C:  # INC E
        this.e = this.inc(this.e)
      case 0x1D:  # DEC E
        this.e = this.dec(this.e)
      case 0x1E:  # LD E, u8
        this.e = this.read_byte_pc()
      case 0x1F:  # RRA
        this.a = this.a | (this.fc() << 8)
        this.set_f(0, 0, 0, this.a & 0x1)
        this.a = this.a >> 1
      case 0x20:  # JR NZ, s8
        this.jr(!this.fz())
      case 0x21:  # LD HL, u16
        this.l = this.read_byte_pc()
        this.h = this.read_byte_pc()
      case 0x22:  # LD (HL+), A
        this.write_byte(this.hl(), this.a)
        this.set_hl(this.hl() + 1)
      case 0x23:  # INC HL
        this.set_hl(this.hl() + 1)
      case 0x24:  # INC H
        this.h = this.inc(this.h)
      case 0x25:  # DEC H
        this.h = this.dec(this.h)
      case 0x26:  # LD H, u8
        this.h = this.read_byte_pc()
      case 0x27:  # DAA
        this.daa()
      case 0x28:  # JR Z, s8
        this.jr(this.fz())
      case 0x29:  # ADD HL, HL
        this.add_half(this.hl())
      case 0x2A:  # LD A, (HL+)
        this.a = this.read_byte(this.hl())
        this.set_hl(this.hl() + 1)
      case 0x2B:  # DEC HL
        this.set_hl(this.hl() - 1)
      case 0x2C:  # INC L
        this.l = this.inc(this.l)
      case 0x2D:  # DEC L
        this.l = this.dec(this.l)
      case 0x2E:  # LD L, u8
        this.l = this.read_byte_pc()
      case 0x2F:  # CPL
        this.a = (~this.a & 0xFF)
        this.set_f(null, 1, 1, null)
      case 0x30:  # JR NC, s8
        this.jr(!this.fc())
      case 0x31:  # LD SP, u16
        this.sp = this.read_half_pc()
      case 0x32:  # LD (HL-), A
        this.write_byte(this.hl(), this.a)
        this.set_hl(this.hl() - 1)
      case 0x33:  # INC SP
        this.sp = (this.sp + 1) & 0xFFFF
      case 0x34:  # INC (HL)
        this.write_byte(this.hl(), this.inc(this.read_byte(this.hl())))
      case 0x35:  # DEC (HL)
        this.write_byte(this.hl(), this.dec(this.read_byte(this.hl())))
      case 0x36:  # LD (HL), u8
        this.write_byte(this.hl(), this.read_byte_pc())
      case 0x37:  # SCF
        this.set_f(null, 0, 0, 1)
      case 0x38:  # JR C, s8
        this.jr(this.fc())
      case 0x39:  # ADD HL, SP
        this.add_half(this.sp)
      case 0x3A:  # LD A, (HL-)
        this.a = this.read_byte(this.hl())
        this.set_hl(this.hl() - 1)
      case 0x3B:  # DEC SP
        this.sp = (this.sp - 1) & 0xFFFF
      case 0x3C:  # INC A
        this.a = this.inc(this.a)
      case 0x3D:  # DEC A
        this.a = this.dec(this.a)
      case 0x3E:  # LD A, u8
        this.a = this.read_byte_pc()
      case 0x3F:  # CCF
        this.set_f(null, 0, 0, !this.fc())
      case 0x40:  # LD B, B
        noop
      case 0x41:  # LD B, C
        this.b = this.c
      case 0x42:  # LD B, D
        this.b = this.d
      case 0x43:  # LD B, E
        this.b = this.e
      case 0x44:  # LD B, H
        this.b = this.h
      case 0x45:  # LD B, L
        this.b = this.l
      case 0x46:  # LD B, (HL)
        this.b = this.read_byte(this.hl())
      case 0x47:  # LD B, A
        this.b = this.a
      case 0x48:  # LD C, B
        this.c = this.b
      case 0x49:  # LD C, C
        noop
      case 0x4A:  # LD C, D
        this.c = this.d
      case 0x4B:  # LD C, E
        this.c = this.e
      case 0x4C:  # LD C, H
        this.c = this.h
      case 0x4D:  # LD C, L
        this.c = this.l
      case 0x4E:  # LD C, (HL)
        this.c = this.read_byte(this.hl())
      case 0x4F:  # LD C, A
        this.c = this.a
      case 0x50:  # LD D, B
        this.d = this.b
      case 0x51:  # LD D, C
        this.d = this.c
      case 0x52:  # LD D, D
        noop
      case 0x53:  # LD D, E
        this.d = this.e
      case 0x54:  # LD D, H
        this.d = this.h
      case 0x55:  # LD D, L
        this.d = this.l
      case 0x56:  # LD D, (HL)
        this.d = this.read_byte(this.hl())
      case 0x57:  # LD D, A
        this.d = this.a
      case 0x58:  # LD E, B
        this.e = this.b
      case 0x59:  # LD E, C
        this.e = this.c
      case 0x5A:  # LD E, D
        this.e = this.d
      case 0x5B:  # LD E, E
        noop
      case 0x5C:  # LD E, H
        this.e = this.h
      case 0x5D:  # LD E, L
        this.e = this.l
      case 0x5E:  # LD E, (HL)
        this.e = this.read_byte(this.hl())
      case 0x5F:  # LD E, A
        this.e = this.a
      case 0x60:  # LD H, B
        this.h = this.b
      case 0x61:  # LD H, C
        this.h = this.c
      case 0x62:  # LD H, D
        this.h = this.d
      case 0x63:  # LD H, E
        this.h = this.e
      case 0x64:  # LD H, H
        noop
      case 0x65:  # LD H, L
        this.h = this.l
      case 0x66:  # LD H, (HL)
        this.h = this.read_byte(this.hl())
      case 0x67:  # LD H, A
        this.h = this.a
      case 0x68:  # LD L, B
        this.l = this.b
      case 0x69:  # LD L, C
        this.l = this.c
      case 0x6A:  # LD L, D
        this.l = this.d
      case 0x6B:  # LD L, E
        this.l = this.e
      case 0x6C:  # LD L, H
        this.l = this.h
      case 0x6D:  # LD L, L
        noop
      case 0x6E:  # LD L, (HL)
        this.l = this.read_byte(this.hl())
      case 0x6F:  # LD L, A
        this.l = this.a
      case 0x70:  # LD (HL), B
        this.write_byte(this.hl(), this.b)
      case 0x71:  # LD (HL), C
        this.write_byte(this.hl(), this.c)
      case 0x72:  # LD (HL), D
        this.write_byte(this.hl(), this.d)
      case 0x73:  # LD (HL), E
        this.write_byte(this.hl(), this.e)
      case 0x74:  # LD (HL), H
        this.write_byte(this.hl(), this.h)
      case 0x75:  # LD (HL), L
        this.write_byte(this.hl(), this.l)
      case 0x76:  # HALT
        this.halt = true
      case 0x77:  # LD (HL), A
        this.write_byte(this.hl(), this.a)
      case 0x78:  # LD A, B
        this.a = this.b
      case 0x79:  # LD A, C
        this.a = this.c
      case 0x7A:  # LD A, D
        this.a = this.d
      case 0x7B:  # LD A, E
        this.a = this.e
      case 0x7C:  # LD A, H
        this.a = this.h
      case 0x7D:  # LD A, L
        this.a = this.l
      case 0x7E:  # LD A, (HL)
        this.a = this.read_byte(this.hl())
      case 0x7F:  # LD A, A
        noop
      case 0x80:  # ADD A, B
        this.add(this.b)
      case 0x81:  # ADD A, C
        this.add(this.c)
      case 0x82:  # ADD A, D
        this.add(this.d)
      case 0x83:  # ADD A, E
        this.add(this.e)
      case 0x84:  # ADD A, H
        this.add(this.h)
      case 0x85:  # ADD A, L
        this.add(this.l)
      case 0x86:  # ADD A, (HL)
        this.add(this.read_byte(this.hl()))
      case 0x87:  # ADD A, A
        this.add(this.a)
      case 0x88:  # ADC A, B
        this.adc(this.b)
      case 0x89:  # ADC A, C
        this.adc(this.c)
      case 0x8A:  # ADC A, D
        this.adc(this.d)
      case 0x8B:  # ADC A, E
        this.adc(this.e)
      case 0x8C:  # ADC A, H
        this.adc(this.h)
      case 0x8D:  # ADC A, L
        this.adc(this.l)
      case 0x8E:  # ADC A, (HL)
        this.adc(this.read_byte(this.hl()))
      case 0x8F:  # ADC A, A
        this.adc(this.a)
      case 0x90:  # SUB A, B
        this.sub(this.b)
      case 0x91:  # SUB A, C
        this.sub(this.c)
      case 0x92:  # SUB A, D
        this.sub(this.d)
      case 0x93:  # SUB A, E
        this.sub(this.e)
      case 0x94:  # SUB A, H
        this.sub(this.h)
      case 0x95:  # SUB A, L
        this.sub(this.l)
      case 0x96:  # SUB A, (HL)
        this.sub(this.read_byte(this.hl()))
      case 0x97:  # SUB A, A
        this.sub(this.a)
      case 0x98:  # SBC A, B
        this.sbc(this.b)
      case 0x99:  # SBC A, C
        this.sbc(this.c)
      case 0x9A:  # SBC A, D
        this.sbc(this.d)
      case 0x9B:  # SBC A, E
        this.sbc(this.e)
      case 0x9C:  # SBC A, H
        this.sbc(this.h)
      case 0x9D:  # SBC A, L
        this.sbc(this.l)
      case 0x9E:  # SBC A, (HL)
        this.sbc(this.read_byte(this.hl()))
      case 0x9F:  # SBC A, A
        this.sbc(this.a)
      case 0xA0:  # AND A, B
        this.and(this.b)
      case 0xA1:  # AND A, C
        this.and(this.c)
      case 0xA2:  # AND A, D
        this.and(this.d)
      case 0xA3:  # AND A, E
        this.and(this.e)
      case 0xA4:  # AND A, H
        this.and(this.h)
      case 0xA5:  # AND A, L
        this.and(this.l)
      case 0xA6:  # AND A, (HL)
        this.and(this.read_byte(this.hl()))
      case 0xA7:  # AND A, A
        this.and(this.a)
      case 0xA8:  # XOR A, B
        this.xor(this.b)
      case 0xA9:  # XOR A, C
        this.xor(this.c)
      case 0xAA:  # XOR A, D
        this.xor(this.d)
      case 0xAB:  # XOR A, E
        this.xor(this.e)
      case 0xAC:  # XOR A, H
        this.xor(this.h)
      case 0xAD:  # XOR A, L
        this.xor(this.l)
      case 0xAE:  # XOR A, (HL)
        this.xor(this.read_byte(this.hl()))
      case 0xAF:  # XOR A, A
        this.xor(this.a)
      case 0xB0:  # OR A, B
        this.or(this.b)
      case 0xB1:  # OR A, C
        this.or(this.c)
      case 0xB2:  # OR A, D
        this.or(this.d)
      case 0xB3:  # OR A, E
        this.or(this.e)
      case 0xB4:  # OR A, H
        this.or(this.h)
      case 0xB5:  # OR A, L
        this.or(this.l)
      case 0xB6:  # OR A, (HL)
        this.or(this.read_byte(this.hl()))
      case 0xB7:  # OR A, A
        this.or(this.a)
      case 0xB8:  # CP A, B
        this.cp(this.b)
      case 0xB9:  # CP A, C
        this.cp(this.c)
      case 0xBA:  # CP A, D
        this.cp(this.d)
      case 0xBB:  # CP A, E
        this.cp(this.e)
      case 0xBC:  # CP A, H
        this.cp(this.h)
      case 0xBD:  # CP A, L
        this.cp(this.l)
      case 0xBE:  # CP A, (HL)
        this.cp(this.read_byte(this.hl()))
      case 0xBF:  # CP A, A
        this.cp(this.a)
      case 0xC0:  # RET NZ
        this.ret(!this.fz())
      case 0xC1:  # POP BC
        this.set_bc(this.pop())
      case 0xC2:  # JP NZ, u16
        this.jp(!this.fz())
      case 0xC3:  # JP u16
        this.jp(null)
      case 0xC4:  # CALL NZ, u16
        this.call(!this.fz())
      case 0xC5:  # PUSH BC
        this.push(this.bc())
      case 0xC6:  # ADD A, u8
        this.add(this.read_byte_pc())
      case 0xC7:  # RST 0x00
        this.rst(0x00)
      case 0xC8:  # RET Z
        this.ret(this.fz())
      case 0xC9:  # RET
        this.ret(null)
      case 0xCA:  # JP Z, u16
        this.jp(this.fz())
      case 0xCB:  # PREFIX CB
        this.prefix()
      case 0xCC:  # CALL Z, u16
        this.call(this.fz())
      case 0xCD:  # CALL u16
        this.call(null)
      case 0xCE:  # ADC A, u8
        this.adc(this.read_byte_pc())
      case 0xCF:  # RST 0x08
        this.rst(0x08)
      case 0xD0:  # RET NC
        this.ret(!this.fc())
      case 0xD1:  # POP DE
        this.set_de(this.pop())
      case 0xD2:  # JP NC, u16
        this.jp(!this.fc())
      case 0xD4:  # CALL NC, u16
        this.call(!this.fc())
      case 0xD5:  # PUSH DE
        this.push(this.de())
      case 0xD6:  # SUB A, u8
        this.sub(this.read_byte_pc())
      case 0xD7:  # RST 0x10
        this.rst(0x10)
      case 0xD8:  # RET C
        this.ret(this.fc())
      case 0xD9:  # RETI
        this.pc = this.pop()
        this.ime = true
      case 0xDA:  # JP C, u16
        this.jp(this.fc())
      case 0xDC:  # CALL C, u16
        this.call(this.fc())
      case 0xDE:  # SBC A, u8
        this.sbc(this.read_byte_pc())
      case 0xDF:  # RST 0x18
        this.rst(0x18)
      case 0xE0:  # LDH (u8), A
        this.write_byte(0xFF00 | this.read_byte_pc(), this.a)
      case 0xE1:  # POP HL
        this.set_hl(this.pop())
      case 0xE2:  # LDH (C), A
        this.write_byte(0xFF00 | this.c, this.a)
      case 0xE5:  # PUSH HL
        this.push(this.hl())
      case 0xE6:  # AND A, u8
        this.and(this.read_byte_pc())
      case 0xE7:  # RST 0x20
        this.rst(0x20)
      case 0xE8:  # ADD SP, s8
        this.sp = this.add_signed_byte(this.sp) & 0xFFFF
      case 0xE9:  # JP (HL)
        this.pc = this.hl()
      case 0xEA:  # LD (u16), A
        this.write_byte(this.read_half_pc(), this.a)
      case 0xEE:  # XOR A, u8
        this.xor(this.read_byte_pc())
      case 0xEF:  # RST 0x28
        this.rst(0x28)
      case 0xF0:  # LDH A, u8
        this.a = this.read_byte(0xFF00 | this.read_byte_pc())
      case 0xF1:  # POP AF
        this.set_af(this.pop())
      case 0xF2:  # LDH A, (C)
        this.a = this.read_byte(0xFF00 | this.c)
      case 0xF3:  # DI
        this.ime = 0
      case 0xF5:  # PUSH AF
        this.push(this.af())
      case 0xF6:  # OR A, u8
        this.or(this.read_byte_pc())
      case 0xF7:  # RST 0x30
        this.rst(0x30)
      case 0xF8:  # LD HL, SP + s8
        this.set_hl(this.add_signed_byte(this.sp))
      case 0xF9:  # LD SP, HL
        this.sp = this.hl()
      case 0xFA:  # LD A, (u16)
        this.a = this.read_byte(this.read_half_pc())
      case 0xFB:  # EI
        this.ime = 1
      case 0xFE:  # CP A, u8
        this.cp(this.read_byte_pc())
      case 0xFF:  # RST 0x38
        this.rst(0x38)
    this.tick(kCycles[opcode])

  def prefix():
    var opcode = this.read_byte_pc()

    var operand
    switch opcode & 0x7:
      case 0x0:
        operand = this.b
      case 0x1:
        operand = this.c
      case 0x2:
        operand = this.d
      case 0x3:
        operand = this.e
      case 0x4:
        operand = this.h
      case 0x5:
        operand = this.l
      case 0x6:
        operand = this.read_byte(this.hl())
      case 0x7:
        operand = this.a
        
    switch opcode & 0xC7:
      case 0x06:
      case 0x86:
      case 0xC6:
        this.tick(8)
      case 0x46:
        this.tick(4)

    var writeback = true
    if opcode <= 0x07:  # RLC
      operand = ((operand << 1) | (operand >> 7)) & 0xFF
      this.set_f(operand == 0, 0, 0, operand & 0x1)
    elif opcode <= 0x0F:  # RRC
      this.set_f(operand == 0, 0, 0, operand & 0x1)
      operand = ((operand >> 1) | (operand << 7)) & 0xFF
    elif opcode <= 0x17:  # RL
      var carry = operand >> 7
      operand = ((operand << 1) | this.fc()) & 0xFF
      this.set_f(operand == 0, 0, 0, carry)
    elif opcode <= 0x1F:  # RR
      var carry = operand & 0x1
      operand = (operand | (this.fc() << 8)) >> 1
      this.set_f(operand == 0, 0, 0, carry)
    elif opcode <= 0x27:  # SLA
      var carry = operand >> 7
      operand = (operand << 1) & 0xFF
      this.set_f(operand == 0, 0, 0, carry)
    elif opcode <= 0x2F:  # SRA
      var carry = operand & 0x1
      operand = (operand & 0x80) | (operand >> 1)
      this.set_f(operand == 0, 0, 0, carry)
    elif opcode <= 0x37:  # SWAP
      operand = ((operand & 0x0F) << 4) | ((operand & 0xF0) >> 4)
      this.set_f(operand == 0, 0, 0, 0)
    elif opcode <= 0x3F:  # SRL
      var carry = operand & 0x1
      operand = operand >> 1
      this.set_f(operand == 0, 0, 0, carry)
    elif opcode <= 0x7F:  # BIT n
      var bit = (opcode - 0x40) >> 3
      this.set_f(!(operand & (1 << bit)), 0, 1, null)
      writeback = false
    elif opcode <= 0xBF:  # RES n
      var bit = (opcode - 0x80) >> 3
      operand = operand & ~(1 << bit)
    elif opcode <= 0xFF:  # SET n
      var bit = (opcode - 0xC0) >> 3
      operand = operand | (1 << bit)

    if writeback:
      switch opcode & 0x7:
        case 0x0:
          this.b = operand
        case 0x1:
          this.c = operand
        case 0x2:
          this.d = operand
        case 0x3:
          this.e = operand
        case 0x4:
          this.h = operand
        case 0x5:
          this.l = operand
        case 0x6:
          this.write_byte(this.hl(), operand)
        case 0x7:
          this.a = operand

  def oam_dma(src):
    src = 0x100 * min(src, 0xF1)
    for dst in 0xFE00 .. 0xFEA0:
      this.write_byte(dst, this.read_byte(src))
      src = src + 1

  def irq():
    var servable = this.ie & this.if_
    if servable:
      this.halt = false
      if this.ime:
        for bit in 0 .. 5:
          var mask = 1 << bit
          if servable & mask:
            this.ime = 0
            this.if_ = this.if_ & ~mask
            this.rst(0x40 + 8 * bit)
            break
            
  def interrupt(mask):
    this.if_ = this.if_ | mask
    
  def interrupt_stat(mask):
    if this.stat & mask:
      this.interrupt(kInterruptStat)
      
  def set_mode(mode):
    switch mode:
      case kModeOam:
        this.interrupt_stat(kStatOam)
      case kModeHBlank:
        this.interrupt_stat(kStatHBlank)
      case kModeVBlank:
        this.interrupt(kInterruptVBlank)
        this.interrupt_stat(kStatVBlank)
    this.ppu_mode = mode
    
  def increment_line():
    this.ly = this.ly + 1
    if this.ly == this.lyc:
      this.interrupt_stat(kStatLine)

  def tick(cycles):
    var kDiv = 256

    if this.tac & 0b100:
      var freq
      switch this.tac & 0b11:
        case 0b00:
          freq = 1024
        case 0b01:
          freq = 16
        case 0b10:
          freq = 64
        case 0b11:
          freq = 256

      this.tima_cycles = this.tima_cycles + cycles
      while this.tima_cycles >= freq:
        this.tima = this.tima + 1
        this.tima_cycles = this.tima_cycles - freq

        if this.tima == 0x100:
          this.tima = this.tma
          this.interrupt(kInterruptTimer)

    this.div_cycles = this.div_cycles + cycles
    while this.div_cycles >= kDiv:
      this.div = (this.div + 1) & 0xFF
      this.div_cycles = this.div_cycles - kDiv
      
    this.ppu_cycles = this.ppu_cycles + cycles
    switch this.ppu_mode:
      case kModeOam:
        if this.ppu_cycles >= 80:
          this.ppu_cycles = this.ppu_cycles - 80
          this.set_mode(kModeVram)
      case kModeVram:
        if this.ppu_cycles >= 172:
          this.ppu_cycles = this.ppu_cycles - 172
          this.set_mode(kModeHBlank)
          this.scanline()
      case kModeHBlank:
        if this.ppu_cycles >= 204:
          this.ppu_cycles = this.ppu_cycles - 204

          this.increment_line()
          if this.ly == kScreenH:
            this.set_mode(kModeVBlank)
            this.window.render()
          else:
            this.set_mode(kModeOam)
      case kModeVBlank:
        if this.ppu_cycles >= 456:
          this.ppu_cycles = this.ppu_cycles - 456

          this.increment_line()
          if this.ly == kScreenH + 10:
            this.ly = 0
            this.set_mode(kModeOam)
            
  def scanline():
    if this.lcd_enabled():
      if this.lcdc & 0x1:
        this.background()
    else:
      this.window.clear(kPalette[0])

  def background():
    var map_base = 0x1800
    if this.lcdc & (1 << 3):
      map_base = map_base + 0x0400

    var tile_base = 0x1000
    if this.lcdc & (1 << 4):
      tile_base = tile_base - 0x1000

    var y = this.ly
    for x in 0 .. kScreenW:
      var texel_x = (x + this.scx) & 0xFF
      var texel_y = (y + this.scy) & 0xFF

      var tile_x = texel_x // 8
      var tile_y = texel_y // 8
      var tile = this.vram[32 * tile_y + tile_x + map_base]

      if (this.lcdc & (1 << 4)) == 0:
        tile = sign_extend(tile)

      var pixel_x = (texel_x & 0x7) ^ 0x7
      var pixel_y = (texel_y & 0x7)

      var addr = 16 * tile + tile_base + 2 * pixel_y
      var lsbc = this.vram[addr + 0] >> pixel_x
      var msbc = this.vram[addr + 1] >> pixel_x
      this.window.set_pixel(x, y, color(this.bgp, (lsbc & 0x1) | ((msbc & 0x1) << 1)))

  def run(rom):
    this.rom = rom
    this.rom.resize(0x8000, 0)

    while sdl_events():
      this.cpu()
      this.irq()

def main():
  var args = arguments()
  if args.size() < 3:
    print("cannot run without rom")
    return

  var rom = read_bin(args[2])
  if rom == null:
    print("cannot read", args[2])
    return

  GameBoy().run(rom)

main()
